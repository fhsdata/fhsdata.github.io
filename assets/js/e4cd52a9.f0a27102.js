/*! For license information please see e4cd52a9.f0a27102.js.LICENSE.txt */
"use strict";(self.webpackChunkreact_native_website=self.webpackChunkreact_native_website||[]).push([[18809],{60123:(e,t,n)=>{n.d(t,{ZP:()=>o});var i=n(24246),a=n(71670);function r(e){const t=Object.assign({admonition:"admonition",p:"p",a:"a"},(0,a.ah)(),e.components);return(0,i.jsx)(t.admonition,{type:"caution",children:(0,i.jsxs)(t.p,{children:["This document refers to the ",(0,i.jsx)(t.a,{href:"fabric-renderer",children:"New Architecture"}),", that is in active roll-out."]})})}const o=function(e={}){const{wrapper:t}=Object.assign({},(0,a.ah)(),e.components);return t?(0,i.jsx)(t,Object.assign({},e,{children:(0,i.jsx)(r,e)})):r(e)}},39046:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>c,toc:()=>l});var i=n(24246),a=n(71670),r=n(60123);const o={id:"view-flattening",title:"View Flattening"},s=void 0,c={id:"view-flattening",title:"View Flattening",description:"View Flattening is an optimization by the React Native renderer to avoid deep layout trees.",source:"@site/architecture/view-flattening.md",sourceDirName:".",slug:"/view-flattening",permalink:"/architecture/view-flattening",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/react-native-website/blob/main/website/architecture/view-flattening.md",tags:[],version:"current",lastUpdatedAt:1646922074,formattedLastUpdatedAt:"Mar 10, 2022",frontMatter:{id:"view-flattening",title:"View Flattening"},sidebar:"architecture",previous:{title:"Cross Platform Implementation",permalink:"/architecture/xplat-implementation"},next:{title:"Threading Model",permalink:"/architecture/threading-model"}},d={},l=[{value:"View Flattening is an optimization by the React Native renderer to avoid deep layout trees.",id:"view-flattening-is-an-optimization-by-the-react-native-renderer-to-avoid-deep-layout-trees",level:4}];function h(e){const t=Object.assign({h4:"h4",p:"p",a:"a",strong:"strong",code:"code",pre:"pre",img:"img"},(0,a.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.ZP,{}),"\n",(0,i.jsx)(t.h4,{id:"view-flattening-is-an-optimization-by-the-react-native-renderer-to-avoid-deep-layout-trees",children:"View Flattening is an optimization by the React Native renderer to avoid deep layout trees."}),"\n",(0,i.jsxs)(t.p,{children:["The React API is designed to be declarative and reusable through composition. This provides a great model for intuitive development. However, in implementation, these qualities of the API lead to the creation of deep ",(0,i.jsx)(t.a,{href:"/architecture/glossary#react-element-tree-and-react-element",children:"React Element Trees"}),", where a large majority of React Element Nodes only affect the layout of a View and don\u2019t render anything on the screen. We call these types of nodes ",(0,i.jsx)(t.strong,{children:"\u201cLayout-Only\u201d"})," Nodes."]}),"\n",(0,i.jsx)(t.p,{children:"Conceptually, each of the Nodes of the React Element Tree have a 1:1 relationship with a view on the screen, therefore rendering a deep React Element Tree that is composed by a large amount of \u201cLayout-Only\u201d Node leads to poor performance during rendering."}),"\n",(0,i.jsx)(t.p,{children:'Here is a common use case that is affected by the cost of "Layout Only" views.'}),"\n",(0,i.jsxs)(t.p,{children:["Imagine you want to render an image and a title that is handled by the ",(0,i.jsx)(t.code,{children:"TitleComponent"}),", and you include this component as a child of the ",(0,i.jsx)(t.code,{children:"ContainerComponent"})," that has some margin styles. After decomposing the components, the React code would look like this:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-jsx",children:"function MyComponent() {\n  return (\n    <View>                          // ReactAppComponent\n      <View style={{margin: 10}} /> // ContainerComponent\n        <View style={{margin: 10}}> // TitleComponent\n          <Image {...} />\n          <Text {...}>This is a title</Text>\n        </View>\n      </View>\n    </View>\n  );\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"As part of the render process, React Native will produce the following trees:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Diagram one",src:n(90830).Z+"",width:"2155",height:"760"})}),"\n",(0,i.jsxs)(t.p,{children:["Note that the Views (2) and (3) are \u201cLayout Only\u201d views, because they are rendered on the screen but they only render a ",(0,i.jsx)(t.code,{children:"margin"})," of ",(0,i.jsx)(t.code,{children:"10 px"})," on top of their children."]}),"\n",(0,i.jsxs)(t.p,{children:["To improve the performance of these types of React Element Trees, the renderer implements a View Flattening mechanism that merges or flattens these types of Nodes, reducing the depth of the ",(0,i.jsx)(t.a,{href:"/architecture/glossary#host-view-tree-and-host-view",children:"host view"})," hierarchy that is rendered on the screen. This algorithm takes into consideration props like: ",(0,i.jsx)(t.code,{children:"margin"}),", ",(0,i.jsx)(t.code,{children:"padding"}),", ",(0,i.jsx)(t.code,{children:"backgroundColor"}),", ",(0,i.jsx)(t.code,{children:"opacity"}),", etc."]}),"\n",(0,i.jsx)(t.p,{children:"The View Flattening algorithm is integrated by design as part of the diffing stage of the renderer, which means that we don\u2019t use extra CPU cycles to optimize the React Element Tree flattening these types of views. As the rest of the core, the View flattening algorithm is implemented in C++ and its benefits are shared by default on all supported platforms."}),"\n",(0,i.jsx)(t.p,{children:"In the case of the previous example, the Views (2) and (3) would be flattened as part of the \u201cdiffing algorithm\u201d and as a result their styles will be merged into the View (1):"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Diagram two",src:n(61658).Z+"",width:"2158",height:"754"})}),"\n",(0,i.jsx)(t.p,{children:"It is important to note that this optimization allows the renderer to avoid the creation and render of two host views. From the user\u2019s perspective there are no visible changes on the screen."})]})}const p=function(e={}){const{wrapper:t}=Object.assign({},(0,a.ah)(),e.components);return t?(0,i.jsx)(t,Object.assign({},e,{children:(0,i.jsx)(h,e)})):h(e)}},71426:(e,t,n)=>{var i=n(27378),a=Symbol.for("react.element"),r=Symbol.for("react.fragment"),o=Object.prototype.hasOwnProperty,s=i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,c={key:!0,ref:!0,__self:!0,__source:!0};function d(e,t,n){var i,r={},d=null,l=null;for(i in void 0!==n&&(d=""+n),void 0!==t.key&&(d=""+t.key),void 0!==t.ref&&(l=t.ref),t)o.call(t,i)&&!c.hasOwnProperty(i)&&(r[i]=t[i]);if(e&&e.defaultProps)for(i in t=e.defaultProps)void 0===r[i]&&(r[i]=t[i]);return{$$typeof:a,type:e,key:d,ref:l,props:r,_owner:s.current}}t.Fragment=r,t.jsx=d,t.jsxs=d},24246:(e,t,n)=>{e.exports=n(71426)},90830:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/diagram-one-3f2f9d7a2fa9d97b6b86fa3bd9b886d1.png"},61658:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/diagram-two-b87959980d29e4a303465a3d0ac82c73.png"},71670:(e,t,n)=>{n.d(t,{Zo:()=>s,ah:()=>r});var i=n(27378);const a=i.createContext({});function r(e){const t=i.useContext(a);return i.useMemo((()=>"function"==typeof e?e(t):{...t,...e}),[t,e])}const o={};function s({components:e,children:t,disableParentContext:n}){let s;return s=n?"function"==typeof e?e({}):e||o:r(e),i.createElement(a.Provider,{value:s},t)}}}]);