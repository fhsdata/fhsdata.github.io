/*! For license information please see f52f3a76.e8f8b709.js.LICENSE.txt */
"use strict";(self.webpackChunkreact_native_website=self.webpackChunkreact_native_website||[]).push([[74151],{86808:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var i=n(24246),o=n(71670);const r={title:"Pointer Events in React Native",authors:["lunaleaps","vincentriemer"],tags:["announcement"],date:new Date("2022-12-13T00:00:00.000Z")},s="Pointer Events in React Native",a={permalink:"/blog/2022/12/13/pointer-events-in-react-native",source:"@site/blog/2022-12-13-pointer-events-in-react-native.md",title:"Pointer Events in React Native",description:"Today we are sharing an experimental cross-platform pointer API for React Native. We\u2019ll go over motivations, how it works, and its benefits to React Native users. There are instructions on how to enable and we\u2019re excited to hear your feedback!",date:"2022-12-13T00:00:00.000Z",formattedDate:"December 13, 2022",tags:[{label:"announcement",permalink:"/blog/tags/announcement"}],readingTime:9.035,hasTruncateMarker:!0,authors:[{name:"Luna Wei",title:"Software Engineer at Meta",url:"https://twitter.com/lunaleaps",imageURL:"https://github.com/lunaleaps.png",key:"lunaleaps"},{name:"Vincent Riemer",title:"Software Engineer at Meta",url:"https://twitter.com/vincentriemer",imageURL:"https://github.com/vincentriemer.png",key:"vincentriemer"}],frontMatter:{title:"Pointer Events in React Native",authors:["lunaleaps","vincentriemer"],tags:["announcement"],date:"2022-12-13T00:00:00.000Z"},unlisted:!1,prevItem:{title:"First-class Support for TypeScript",permalink:"/blog/2023/01/03/typescript-first"},nextItem:{title:"React Native Core Contributor Summit 2022",permalink:"/blog/2022/11/22/react-native-core-contributor-summit-2022"}},l={authorsImageUrls:[void 0,void 0]},c=[{value:"Going Beyond Touch",id:"going-beyond-touch",level:3},{value:"Looking to Web",id:"looking-to-web",level:3},{value:"Porting Web Platform Tests",id:"porting-web-platform-tests",level:2},{value:"How it works",id:"how-it-works",level:2},{value:"Implementation Progress",id:"implementation-progress",level:2},{value:"Events",id:"events",level:3},{value:"Event Properties",id:"event-properties",level:3},{value:"Future Work and Exploration",id:"future-work-and-exploration",level:2},{value:"Trying it Out",id:"trying-it-out",level:2},{value:"Enable Feature Flags",id:"enable-feature-flags",level:3},{value:"iOS-specific",id:"ios-specific",level:3},{value:"Android-specific",id:"android-specific",level:3},{value:"JavaScript",id:"javascript",level:3},{value:"Feedback Welcome",id:"feedback-welcome",level:2}];function d(e){const t=Object.assign({p:"p",a:"a",h3:"h3",h2:"h2",img:"img",ol:"ol",li:"li",code:"code",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",admonition:"admonition",ul:"ul",pre:"pre"},(0,o.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"Today we are sharing an experimental cross-platform pointer API for React Native. We\u2019ll go over motivations, how it works, and its benefits to React Native users. There are instructions on how to enable and we\u2019re excited to hear your feedback!"}),"\n",(0,i.jsxs)(t.p,{children:["It\u2019s been over a year since we shared ",(0,i.jsx)(t.a,{href:"https://reactnative.dev/blog/2021/08/26/many-platform-vision",children:"our many platform vision"})," on the wins of building beyond mobile and how it sets a higher bar for all platforms. During this time, we've increased our investments in React Native for VR, Desktop, and Web. With differences in hardware and interactions on these platforms, it raised the question of how React Native should holistically handle input."]}),"\n",(0,i.jsx)(t.h3,{id:"going-beyond-touch",children:"Going Beyond Touch"}),"\n",(0,i.jsx)(t.p,{children:"Desktop and VR have historically relied on mouse and keyboard input where mobile is primarily touch. That narrative has evolved with touch-screen laptops and growing needs to support interactions via keyboard and pen on mobile. All of which the React Native touch event system is not equipped to handle."}),"\n",(0,i.jsx)(t.p,{children:"As a result, users of out-of-tree platforms fork React Native and/or create custom native components and modules to support critical features like hover detection or left-click. This divergence leads to prop redundancy with event handlers serving similar purposes but for different platforms. It adds complexity to the framework and makes code-sharing between platforms tedious. For these reasons, the team was motivated to provide a cross-platform pointer API."}),"\n",(0,i.jsx)(t.p,{children:"React Native aims to provide robust and expressive APIs to build for many platforms while maintaining characteristic platform experiences. Designing such an API is challenging yet thankfully there is prior art in the pointer space that React Native can leverage."}),"\n",(0,i.jsx)(t.h3,{id:"looking-to-web",children:"Looking to Web"}),"\n",(0,i.jsx)(t.p,{children:"Web is a platform with similar challenges in scaling to many platforms while also considering future-proof design. The World Wide Web consortium (W3C) is tasked with setting standards and proposals to build a Web that is interoperable amongst different platforms and browsers."}),"\n",(0,i.jsxs)(t.p,{children:["Most relevant for our needs, the W3C has defined behavior for an abstract form of input, called a pointer. The ",(0,i.jsx)(t.a,{href:"https://www.w3.org/TR/pointerevents3/",children:"Pointer Events"})," specification builds on mouse events and aims to provide a single set of events and interfaces for cross-device pointer input while still allowing for device-specific handling when necessary."]}),"\n",(0,i.jsx)(t.p,{children:"Following the Pointer Events specification provides React Native users many benefits. Beyond addressing the problems mentioned earlier, it raises the capabilities of platforms that haven\u2019t historically had to consider multi-input type interactions. Think attaching a bluetooth mouse to your Android phone or the Apple pencil supporting hover on the iPad M2."}),"\n",(0,i.jsxs)(t.p,{children:["Being spec-complaint also provides opportunity for knowledge sharing between Web and React Native. Education of Web expectations around Pointer Events can doubly serve React Native developers. However, we also recognize that React Native requirements are different than web and our approach to specifications is best effort with well documented deviations so expectations are clear. There is related work of aligning certain Web standards to ",(0,i.jsx)(t.a,{href:"https://github.com/react-native-community/discussions-and-proposals/pull/496",children:"reduce API fragmentation"})," in accessibility and performance APIs."]}),"\n",(0,i.jsx)(t.h2,{id:"porting-web-platform-tests",children:"Porting Web Platform Tests"}),"\n",(0,i.jsxs)(t.p,{children:["While the Pointer Events specification provides interfaces and behavior descriptions of the API, we found it wasn\u2019t specific enough for us to confidently make changes and point to the specification as verification. However, web browsers use another mechanism to ensure compliance and interoperability \u2014 the ",(0,i.jsx)(t.a,{href:"https://web-platform-tests.org/",children:"Web Platform Tests"}),"!"]}),"\n",(0,i.jsx)(t.p,{children:"The Web Platform Tests are written to work against the browser\u2019s imperative DOM APIs \u2014 unsupported by React Native as it uses its own view primitives. This means that we aren\u2019t able to code-share the tests with browsers and instead have an analogous testing API for React Native that makes it easier to port those Web Platform Tests."}),"\n",(0,i.jsx)(t.p,{children:"We implemented a new manual testing framework which we are now using for verifying our implementations through RNTester. These tests are tentatively named the RNTester Platform Tests and are still fairly basic. Our implementation provides an API to construct test cases as components themselves which are rendered and where the results are reported solely through the UI."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"GIF showing a side by side comparison of the &quot;Pointer Events hoverable pointer attributes test&quot; running in React Native (iOS) on the left, and Web (the original implementation) on the right.",src:n(38482).Z+"",width:"960",height:"540"})}),"\n",(0,i.jsx)(t.p,{children:"These tests will continue to be helpful as we further the completeness of our Pointer Events implementation. These tests will also scale to test Pointer Events implementations on platforms beyond Android and iOS. As the number of tests in our suite increase we will be looking to automate the running of these tests so that we are better equipped to catch regressions in our implementations."}),"\n",(0,i.jsx)(t.h2,{id:"how-it-works",children:"How it works"}),"\n",(0,i.jsx)(t.p,{children:"Much of our Pointer Events implementation builds off existing infrastructure for dispatching touch events. On Android and iOS we leverage the relevant MotionEvent and UITouch events. The general flow of event dispatching is illustrated below."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Diagram of code flow for interpreting Android and iOS UI input events into Pointer Events. On Android, input handlers &quot;onTouchEvent&quot; and &quot;onHoverEvent&quot; fire &quot;MotionEvents&quot; that are interpreted into Pointer Events and through JSI are dispatched to the React renderer. iOS takes a similar path with input handlers &quot;touchesBegan&quot;, &quot;touchesMoved&quot;, &quot;touchesEnded&quot;, and &quot;hovering&quot; interpreting &quot;UITouch&quot; and &quot;UIEvent&quot; into Pointer Events.",src:n(99248).Z+"",width:"1980",height:"985"})}),"\n",(0,i.jsx)(t.p,{children:"Using Android as an example, the general approach to leveraging platform events are:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["Iterate through all pointers of the ",(0,i.jsx)(t.code,{children:"MotionEvent"})," and do a depth-first search to determine the target React view of each pointer and its ancestral path."]}),"\n",(0,i.jsxs)(t.li,{children:["Map the category of ",(0,i.jsx)(t.code,{children:"MotionEvent"})," to the relevant pointer events. There is a 1-to-many relationship between ",(0,i.jsx)(t.code,{children:"MotionEvent"})," and ",(0,i.jsx)(t.code,{children:"PointerEvent"}),". In the illustration of their relationship, dotted lines indicate fired events if the pointing device does not support hover."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"A diagram illustrating the relationship of types of Android MotionEvents into Pointer Events fired. Some pointer events are conditionally fired if pointing device does not support hover. &quot;ACTION_DOWN&quot; and &quot;ACTION_POINTER_DOWN&quot; fire pointerdown and conditionally fire pointerenter, pointerover. &quot;ACTION_MOVE&quot; and &quot;ACTION_HOVER_MOVE&quot; fire pointerover, pointermove, pointerout, pointerup. &quot;ACTION_UP&quot; and &quot;ACTION_POINTER_UP&quot; fire pointerup and conditionally fire pointerout, pointerleave.",src:n(46202).Z+"",width:"1506",height:"700"})}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["Build the ",(0,i.jsx)(t.code,{children:"PointerEvent"})," interface with platform details from the ",(0,i.jsx)(t.code,{children:"MotionEvent"})," and cached state of previous interactions. (Ex. ",(0,i.jsxs)(t.a,{href:"https://w3c.github.io/pointerevents/#the-button-property",children:["the ",(0,i.jsx)(t.code,{children:"button"})," property"]}),")"]}),"\n",(0,i.jsxs)(t.li,{children:["Dispatch the pointer events from Android to React Native\u2019s ",(0,i.jsx)(t.a,{href:"https://github.com/facebook/react-native/blob/main/ReactCommon/react/renderer/core/EventQueueProcessor.cpp#L20",children:"core event queue"})," and leverage JSI to call the ",(0,i.jsx)(t.a,{href:"https://github.com/facebook/react/blob/main/packages/react-native-renderer/src/ReactFabricEventEmitter.js#L83",children:(0,i.jsx)(t.code,{children:"dispatchEvent"})})," method in ",(0,i.jsx)(t.code,{children:"react-native-renderer"})," which iterates through the React tree for the bubble and capture phase of the event."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"implementation-progress",children:"Implementation Progress"}),"\n",(0,i.jsx)(t.p,{children:"When it comes to our current progress of implementing the Pointer Events specification we\u2019ve focused on a solid baseline implementation of the most common events that handle things like pressing, hovering, and moving."}),"\n",(0,i.jsx)(t.h3,{id:"events",children:"Events"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Implemented"}),(0,i.jsx)(t.th,{children:"Work in Progress"}),(0,i.jsx)(t.th,{children:"Yet to be Implemented"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"onPointerOver"}),(0,i.jsx)(t.td,{children:"onPointerCancel"}),(0,i.jsx)(t.td,{children:"onClick"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"onPointerEnter"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"onContextMenu"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"onPointerDown"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"onGotPointerCapture"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"onPointerMove"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"onLostPointerCapture"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"onPointerUp"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"onPointerRawUpdate"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"onPointerOut"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"onPointerLeave"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{})]})]})]}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsx)(t.p,{children:'onPointerCancel has been hooked up to the native platform\u2019s "cancel" event but this does not necessarily correspond to when the web platform expects them to fire.'})}),"\n",(0,i.jsx)(t.h3,{id:"event-properties",children:"Event Properties"}),"\n",(0,i.jsxs)(t.p,{children:["For each of the events mentioned above we\u2019ve also implemented the majority of the properties expected in the PointerEvent object \u2014 though in React Native these are exposed through the ",(0,i.jsx)(t.code,{children:"event.nativeEvent"})," property. You can find an enumeration of all the implemented properties in the ",(0,i.jsx)(t.a,{href:"https://github.com/facebook/react-native/blob/59ee57352738f030b41589a450209e51e44bbb06/Libraries/Types/CoreEventTypes.js#L175",children:"event object\u2019s Flowtype interface definition"}),". One notable exception to being completely implemented is the ",(0,i.jsx)(t.code,{children:"relatedTarget"})," property as exposing a native view reference in this ad-hoc manner isn\u2019t trivial."]}),"\n",(0,i.jsx)(t.h2,{id:"future-work-and-exploration",children:"Future Work and Exploration"}),"\n",(0,i.jsx)(t.p,{children:"In addition to the events above there are also some other APIs related to Pointer Events. In the future, we plan to be implement these APIs as a part of this effort. These APIs include:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Pointer Capture API","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Includes the imperative API exposed on element references including ",(0,i.jsx)(t.code,{children:"setPointerCapture()"}),", ",(0,i.jsx)(t.code,{children:"releasePointerCapture()"}),", and ",(0,i.jsx)(t.code,{children:"hasPointerCapture()"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"touch-action"})," style property","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The web uses this CSS property to declaratively negotiate gestures between the browser and a website\u2019s own event handling code. In React Native this could be used for negotiating the event handling between a View\u2019s pointer event handlers and a parent ScrollView."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"click"}),", ",(0,i.jsx)(t.code,{children:"contextmenu"}),", ",(0,i.jsx)(t.code,{children:"auxclick"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"click"})," is an abstract definition of interaction that may be triggered through accessibility paradigms or other characteristic platform interactions."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Another benefit of the native Pointer Events implementation is that it will allow us to revisit and improve various forms of gesture handling currently limited only to touch events and handled in JavaScript by the Responder, Pressability, and PanResponder APIs."}),"\n",(0,i.jsxs)(t.p,{children:["Furthermore, we are continuing to explore including an implementation of the ",(0,i.jsx)(t.code,{children:"EventTarget"})," interface for React Native host components (i.e. ",(0,i.jsx)(t.code,{children:"add"}),"/",(0,i.jsx)(t.code,{children:"removeEventListener"}),") which we believe will make possible more user-land abstractions for handling pointer interactions."]}),"\n",(0,i.jsx)(t.h2,{id:"trying-it-out",children:"Trying it Out"}),"\n",(0,i.jsx)(t.p,{children:"Our Pointer Events implementation is still experimental but we\u2019re interested in getting feedback from the community on what we\u2019ve shared. If you are interested in trying this API you\u2019ll need to enable a couple feature flags:"}),"\n",(0,i.jsx)(t.h3,{id:"enable-feature-flags",children:"Enable Feature Flags"}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsxs)(t.p,{children:["Pointer Events are only implemented for the ",(0,i.jsx)(t.a,{href:"https://reactnative.dev/docs/the-new-architecture/use-app-template",children:"New Architecture (Fabric)"})," and are only available for React Native 0.71+ which at the time of writing is a release candidate."]})}),"\n",(0,i.jsxs)(t.p,{children:["In your entry JavaScript file (index.js in the default React Native app template) you\u2019ll need to enable the ",(0,i.jsx)(t.code,{children:"shouldEmitW3CPointerEvents"})," flag for Pointer Events and ",(0,i.jsx)(t.code,{children:"shouldPressibilityUseW3CPointerEventsForHover"})," to use Pointer Events in ",(0,i.jsx)(t.code,{children:"Pressability"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"import ReactNativeFeatureFlags from 'react-native/Libraries/ReactNative/ReactNativeFeatureFlags';\n\n// enable the JS-side of the w3c PointerEvent implementation\nReactNativeFeatureFlags.shouldEmitW3CPointerEvents = () => true;\n\n// enable hover events in Pressibility to be backed by the PointerEvent implementation\nReactNativeFeatureFlags.shouldPressibilityUseW3CPointerEventsForHover =\n  () => true;\n"})}),"\n",(0,i.jsx)(t.h3,{id:"ios-specific",children:"iOS-specific"}),"\n",(0,i.jsxs)(t.p,{children:["In order to ensure that the pointer events are sent from the native iOS renderer you\u2019ll need to flip a native feature flag in your native app\u2019s initialization code (typically ",(0,i.jsx)(t.code,{children:"AppDelegate.mm"}),")."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-objc",children:"#import <React/RCTConstants.h>\n\n// ...\n\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n{\n    RCTSetDispatchW3CPointerEvents(YES);\n\n    // ...\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Note that to ensure that the Pointer Event implementation can distinguish between mouse and touch pointers on iOS you need to add ",(0,i.jsx)(t.a,{href:"https://developer.apple.com/documentation/bundleresources/information_property_list/uiapplicationsupportsindirectinputevents",children:(0,i.jsx)(t.code,{children:"UIApplicationSupportsIndirectInputEvents"})})," to your Xcode project\u2019s ",(0,i.jsx)(t.code,{children:"info.plist"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"android-specific",children:"Android-specific"}),"\n",(0,i.jsxs)(t.p,{children:["Similarly to iOS Android has a feature flag that you\u2019ll need to enable in your app\u2019s initialization \u2014 typically your ",(0,i.jsx)(t.code,{children:"onCreate"})," for your root React activity or surface."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-java",children:"import com.facebook.react.config.ReactFeatureFlags;\n\n//... somewhere in initialization\n\n@Override\npublic void onCreate() {\n    ReactFeatureFlags.dispatchPointerEvents = true;\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"javascript",children:"JavaScript"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"function onPointerOver(event) {\n  console.log(\n    'Over blue box offset: ',\n    event.nativeEvent.offsetX,\n    event.nativeEvent.offsetY,\n  );\n}\n\n// ... in some component\n<View\n  onPointerOver={onPointerOver}\n  style={{height: 100, width: 100, backgroundColor: 'blue'}}\n/>;\n"})}),"\n",(0,i.jsx)(t.h2,{id:"feedback-welcome",children:"Feedback Welcome"}),"\n",(0,i.jsxs)(t.p,{children:["Today Pointer Events are used by our VR platform and powering the Oculus Store, but we're also looking for early community feedback on both our approach and what we have for an implementation so far. We are excited to share our further progress with you and if you have questions or thoughts around this work, join us on the ",(0,i.jsx)(t.a,{href:"https://github.com/react-native-community/discussions-and-proposals/discussions/557",children:"dedicated discussion on Pointer Events"}),"."]})]})}const h=function(e={}){const{wrapper:t}=Object.assign({},(0,o.ah)(),e.components);return t?(0,i.jsx)(t,Object.assign({},e,{children:(0,i.jsx)(d,e)})):d(e)}},71426:(e,t,n)=>{var i=n(27378),o=Symbol.for("react.element"),r=Symbol.for("react.fragment"),s=Object.prototype.hasOwnProperty,a=i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,l={key:!0,ref:!0,__self:!0,__source:!0};function c(e,t,n){var i,r={},c=null,d=null;for(i in void 0!==n&&(c=""+n),void 0!==t.key&&(c=""+t.key),void 0!==t.ref&&(d=t.ref),t)s.call(t,i)&&!l.hasOwnProperty(i)&&(r[i]=t[i]);if(e&&e.defaultProps)for(i in t=e.defaultProps)void 0===r[i]&&(r[i]=t[i]);return{$$typeof:o,type:e,key:c,ref:d,props:r,_owner:a.current}}t.Fragment=r,t.jsx=c,t.jsxs=c},24246:(e,t,n)=>{e.exports=n(71426)},99248:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/pointer-events-code-flow-5f598d1362801753c43a1936f08a509d.png"},46202:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/pointer-events-motionevent-relationship-892a4a19c30a230188599cc520c57804.png"},38482:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/pointer-events-wpt-demo-f524c11634eb4f9b5a907c5730f27321.gif"},71670:(e,t,n)=>{n.d(t,{Zo:()=>a,ah:()=>r});var i=n(27378);const o=i.createContext({});function r(e){const t=i.useContext(o);return i.useMemo((()=>"function"==typeof e?e(t):{...t,...e}),[t,e])}const s={};function a({components:e,children:t,disableParentContext:n}){let a;return a=n?"function"==typeof e?e({}):e||s:r(e),i.createElement(o.Provider,{value:a},t)}}}]);